# SOLID 原則

オブジェクト指向プログラミングにおいて

- 変更しやすく
- 理解しやすく
- 再利用しやすい
  モジュールを設計/開発をするための 5 つの原則

## 意義

以下のようなことを防ぐ

影響範囲が大きい、コードの依存関係が複雑、再利用しにくく同じようなコードが大量発生、単体テストができないほど複雑

# 5 つの原則

- S:単一責任の原則(single responsibility)

クラスはたったひとつのアクター（そのクラスを使用するユーザーやステークホルダー）に対して責務を負うべき。

さもないと、あるアクターのために行った変更の影響が別のアクターにも及び、バグが生まれてしまう。

- O:オープンクローズドの原則(open closed)

ソフトウェアの構成要素は拡張に対して開かれていて、修正に対して閉じているべき。

（ソフトウェアの振る舞いは既存の成果物を変更せずに拡張できるようにすべき）

さもないと、既存コードに修正を加える際に、予期せぬバグが発生してしまう。

- L:リスコフの置換原則(liskov substitution)

サブクラスは、そのスーパークラスと置換可能でなければならない

継承は「Is - a」関係 だけでなく「振る舞いの同等性」も追加する必要がある

さもないと、スーパークラスとサブタイプが異なる挙動を持つことになる。

- I:インターフェイス分離の原則(interface segregation)

インターフェイスのクライアントにとって利用しないプロパティやメソッドへの依存を強制してはならない

さもないと、インターフェイスの変更時に実装側で必ずしも使わないメソッドでも実装側の修正が必要になっていまう。

- D:依存性逆転の原則(dependency inversion)

(1).上位のモジュールは下位のモジュールに依存してはならない。どちらもモジュールの「抽象」に依存すべき

(2).「抽象」は実装の詳細に依存してはならない。実装の詳細が「抽象」に依存すべき

さもないと、下位モジュールの変更が上位モジュールに影響を与えてしまう。

## 発展 1:契約による設計

プログラムコードの中にプログラムが満たすべき使用について記述することで、正確で頑健なソフトウェアとする設計技法

- 利用する側
  前提条件（hogehoge という条件でメソッド A を利用したい）と提示する。

例えば、メソッド開始時に保証されるべき条件。メソッドの引数、メソッド開始時のインスタンス状態。

- 利用される側
  事後条件（hogehoge の条件でメソッド A を呼び出してくれれば、marumaru という結果を保証する）と提示する。

例えば、メソッド正常終了時に保証されるべき条件。インスタンスの状態、クライアントに返す値。

リスコフ条件を満たすためには、サブクラスの事前条件はスーパークラスと同一もしくは弱くし、事後条件はスーパークラスと同一もしくは強くする。

## 発展 2:Dependency Injection

クラス間の依存関係をソースコードから排除するために、コンストラクタやセッターを通じて外部からオブジェクトを渡せるようにするパターン。

DI コンテナ：自動で DI を行いインスタンスを構築してくれる仕組み
